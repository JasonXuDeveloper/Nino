using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Runtime.CompilerServices;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Nino.Generator;

/// <summary>
/// Incremental source generator that collects and reports all types discovered in the compilation.
/// Uses two-tier architecture:
///
/// TIER 1 - NinoType Definitions (per-item cached, no Collect):
/// - Pipeline 1: Non-generic types with [NinoType] attribute
/// - Pipeline 2: Non-generic types inheriting from NinoType
/// Note: Generic definitions like Foo&lt;T&gt; are skipped - only non-generic types output here.
///
/// TIER 2 - Expanded Types (Collect + dedup):
/// - Pipeline 3: Recursively expand NinoTypes' members, bases, interfaces
///   → Constructed generic NinoTypes (e.g., Foo&lt;int&gt;) + auxiliary types (e.g., int, List&lt;T&gt;)
/// - Pipeline 4: Generic method type arguments (e.g., Serialize&lt;List&lt;int&gt;&gt;)
///   → Captures auxiliary types like List&lt;int&gt; even without [NinoType]
/// - Pipeline 5: Constructed generic types from statements (conservative scan for polymorphism)
///   → Catches cases like: var x = new Foo&lt;int&gt;(); Serialize&lt;IFoo&gt;(x);
///
/// Caching strategy:
/// - Tier 1: Per-item cached (no Collect) - maximum incrementality
/// - Tier 2: Collect required for deduplication (same type from multiple sources)
/// </summary>
// [Generator(LanguageNames.CSharp)] // Disabled: not yet needed, re-enable when ready
public class TypeCollectionReportGenerator : IIncrementalGenerator
{
    private const string NinoTypeAttributeName = "NinoTypeAttribute";
    private const string NinoTypeAttributeFullName = "Nino.Core.NinoTypeAttribute";

    // Generator metadata retrieved from assembly at load time
    private static readonly string GeneratorName =
        typeof(TypeCollectionReportGenerator).Assembly.GetName().Name ?? "Nino.Generator";
    private static readonly string GeneratorVersion =
        typeof(TypeCollectionReportGenerator).Assembly.GetName().Version?.ToString() ?? "1.0.0";

    #region Object Pooling for Hot Paths

    // ThreadStatic pools avoid allocations in frequently-called methods
    // Each thread gets its own pool to avoid synchronization overhead
    // SAFETY: Clear() releases all ISymbol references - only the container is reused
    [ThreadStatic] private static Stack<ITypeSymbol>? _typeStack;
    [ThreadStatic] private static HashSet<string>? _stringSet;

    private static Stack<ITypeSymbol> RentTypeStack()
    {
        var stack = _typeStack;
        if (stack != null)
        {
            _typeStack = null;
            return stack;
        }
        return new Stack<ITypeSymbol>();
    }

    private static void ReturnTypeStack(Stack<ITypeSymbol> stack)
    {
        // Clear all ISymbol references to prevent holding onto stale Compilation data
        stack.Clear();
        _typeStack = stack;
    }

    private static HashSet<string> RentStringSet()
    {
        var set = _stringSet;
        if (set != null)
        {
            _stringSet = null;
            return set;
        }
        return new HashSet<string>(StringComparer.Ordinal);
    }

    private static void ReturnStringSet(HashSet<string> set)
    {
        // Clear all references
        set.Clear();
        _stringSet = set;
    }

    #endregion

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // ═══════════════════════════════════════════════════════════════════════
        // STATIC INITIALIZATION: Generated once, never re-evaluated
        // ═══════════════════════════════════════════════════════════════════════
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource("NinoTypeCollection_Helpers.g.cs", $"""
                // <auto-generated/>
                #nullable enable

                // Static helpers for NinoType collection
                // Generated by {GeneratorName} v{GeneratorVersion}
                // This file is generated once and never changes

                // When adding generated types/methods, include:
                // [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
                // [System.CodeDom.Compiler.GeneratedCode("{GeneratorName}", "{GeneratorVersion}")]
                """);
        });

        // ═══════════════════════════════════════════════════════════════════════
        // TIER 1: NinoType Definitions (per-item cached, NO Collect)
        // These output directly without aggregation for maximum incrementality.
        // ═══════════════════════════════════════════════════════════════════════

        // Pipeline 1: Types with [NinoType] attribute directly
        // Uses ForAttributeWithMetadataName - 99x more efficient than CreateSyntaxProvider
        var ninoTypesWithAttribute = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                NinoTypeAttributeFullName,
                predicate: static (node, _) => node is TypeDeclarationSyntax,
                transform: static (ctx, ct) =>
                {
                    ct.ThrowIfCancellationRequested();
                    var symbol = ctx.SemanticModel.GetDeclaredSymbol(ctx.TargetNode, ct);
                    if (symbol is not ITypeSymbol typeSymbol || ContainsTypeParameter(typeSymbol))
                        return (TypeModel?)null;
                    return new TypeModel(typeSymbol);
                })
            .Where(static model => model.HasValue)
            .Select(static (model, _) => model!.Value)
            .WithTrackingName("Pipeline1_AttributedNinoTypes");

        // Pipeline 2: Types inheriting from NinoType (without attribute themselves)
        // Disjoint from Pipeline 1 by filtering out types with attribute
        var inheritedNinoTypes = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is TypeDeclarationSyntax { BaseList: not null },
                transform: static (ctx, ct) =>
                {
                    ct.ThrowIfCancellationRequested();
                    if (ctx.SemanticModel.GetDeclaredSymbol(ctx.Node, ct) is not ITypeSymbol typeSymbol)
                        return (TypeModel?)null;

                    // EXCLUDE types with attribute - Pipeline 1 handles those
                    if (HasNinoTypeAttribute(typeSymbol))
                        return null;

                    if (!IsNinoType(typeSymbol) || ContainsTypeParameter(typeSymbol))
                        return null;

                    return new TypeModel(typeSymbol);
                })
            .Where(static model => model.HasValue)
            .Select(static (model, _) => model!.Value)
            .WithTrackingName("Pipeline2_InheritedNinoTypes");

        // TIER 1 OUTPUT: Per-item cached, no Collect needed
        context.RegisterSourceOutput(ninoTypesWithAttribute, GenerateForType);
        context.RegisterSourceOutput(inheritedNinoTypes, GenerateForType);

        // ═══════════════════════════════════════════════════════════════════════
        // TIER 2: Expanded Types (Collect + dedup)
        // Recursively expand NinoTypes to find:
        // - Constructed generic NinoTypes (e.g., Foo<int> where Foo<T> is NinoType)
        // - All non-NinoTypes (members, bases, type arguments)
        // ═══════════════════════════════════════════════════════════════════════

        // Pipeline 3: Recursively expand ALL NinoTypes (attributed + inherited)
        // Extracts from members, bases, interfaces, and type arguments
        var expandedTypesFromNinoTypes = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) =>
                {
                    // Only process types that could potentially be NinoTypes
                    // Types must have either attributes OR base types to be NinoTypes
                    // This filters out 50-90% of types before expensive semantic analysis
                    if (node is not TypeDeclarationSyntax typeDecl)
                        return false;
                    return typeDecl.AttributeLists.Count > 0 || typeDecl.BaseList != null;
                },
                transform: static (ctx, ct) =>
                {
                    ct.ThrowIfCancellationRequested();
                    if (ctx.SemanticModel.GetDeclaredSymbol(ctx.Node, ct) is not INamedTypeSymbol symbol)
                        return default(EquatableArray<TypeModel>);

                    // Must be a NinoType (attributed or inherited) and closed (no type parameters)
                    if (!IsNinoType(symbol) || ContainsTypeParameter(symbol))
                        return default;

                    var types = new List<TypeModel>();

                    // Extract from member types (fields, properties)
                    foreach (var memberType in GetMemberTypes(symbol))
                    {
                        ExtractAllTypes(memberType, types, ct);
                    }

                    // Extract from base type
                    if (symbol.BaseType != null)
                    {
                        ExtractAllTypes(symbol.BaseType, types, ct);
                    }

                    // Extract from implemented interfaces
                    foreach (var iface in symbol.Interfaces)
                    {
                        ExtractAllTypes(iface, types, ct);
                    }

                    return types.Count > 0
                        ? new EquatableArray<TypeModel>(types.ToArray())
                        : default;
                })
            .Where(static arr => arr.Length > 0)
            .WithTrackingName("Pipeline3_ExpandedFromNinoTypes");

        // Pipeline 4: Types from generic method type arguments
        var typesFromGenericCalls = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) =>
                    node is InvocationExpressionSyntax
                    {
                        Expression: GenericNameSyntax or
                                    MemberAccessExpressionSyntax { Name: GenericNameSyntax }
                    },
                transform: static (ctx, ct) =>
                {
                    ct.ThrowIfCancellationRequested();
                    var invocation = (InvocationExpressionSyntax)ctx.Node;
                    var symbolInfo = ctx.SemanticModel.GetSymbolInfo(invocation, ct);

                    if (symbolInfo.Symbol is not IMethodSymbol { IsGenericMethod: true } methodSymbol)
                        return default(EquatableArray<TypeModel>);

                    var types = new List<TypeModel>();
                    foreach (var typeArg in methodSymbol.TypeArguments)
                    {
                        ct.ThrowIfCancellationRequested();
                        ExtractAllTypes(typeArg, types, ct);
                    }

                    return types.Count > 0
                        ? new EquatableArray<TypeModel>(types.ToArray())
                        : default;
                })
            .Where(static arr => arr.Length > 0)
            .WithTrackingName("Pipeline4_TypesFromGenericCalls");

        // Pipeline 5: Constructed generic NinoTypes from type usages in statements
        // Captures polymorphic cases: e.g., BaseType x = new Foo<int>(); where Foo<T> is NinoType
        // Scans all GenericNameSyntax in statements/expressions (variable decls, casts, object creations, etc.)
        var typesFromStatements = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) =>
                    node is GenericNameSyntax &&
                    node.Parent is not BaseListSyntax &&
                    node.Parent?.Parent is not BaseListSyntax &&
                    node.Parent is not AttributeSyntax &&
                    node.Parent?.Parent is not AttributeSyntax &&
                    IsInExecutableContext(node),
                transform: static (ctx, ct) =>
                {
                    ct.ThrowIfCancellationRequested();
                    var genericName = (GenericNameSyntax)ctx.Node;

                    var typeInfo = ctx.SemanticModel.GetTypeInfo(genericName, ct);
                    var typeSymbol = typeInfo.Type ?? typeInfo.ConvertedType;

                    if (typeSymbol is not INamedTypeSymbol { IsGenericType: true } namedType)
                        return default(EquatableArray<TypeModel>);

                    if (ContainsTypeParameter(namedType))
                        return default;

                    var types = new List<TypeModel>();
                    ExtractAllTypes(namedType, types, ct);

                    return types.Count > 0
                        ? new EquatableArray<TypeModel>(types.ToArray())
                        : default;
                })
            .Where(static arr => arr.Length > 0)
            .WithTrackingName("Pipeline5_TypesFromStatements");

        // TIER 2 OUTPUT: Deduplicate each pipeline separately for better caching
        // This creates more "checkpoints" - if only one pipeline changes, the others stay cached
        var dedupedFromNinoTypes = expandedTypesFromNinoTypes
            .SelectMany(static (arr, _) => arr)
            .Collect()
            .Select(static (types, _) => DeduplicateTypes(types))
            .WithTrackingName("Tier2_DedupedFromNinoTypes");

        var dedupedFromGenericCalls = typesFromGenericCalls
            .SelectMany(static (arr, _) => arr)
            .Collect()
            .Select(static (types, _) => DeduplicateTypes(types))
            .WithTrackingName("Tier2_DedupedFromGenericCalls");

        var dedupedFromStatements = typesFromStatements
            .SelectMany(static (arr, _) => arr)
            .Collect()
            .Select(static (types, _) => DeduplicateTypes(types))
            .WithTrackingName("Tier2_DedupedFromStatements");

        // Final combine and global deduplication across all pipelines
        var allExpandedTypes = dedupedFromNinoTypes
            .Combine(dedupedFromGenericCalls)
            .Combine(dedupedFromStatements)
            .SelectMany(static (data, _) =>
            {
                var ((fromNinoTypes, fromGenericCalls), fromStatements) = data;
                var seen = new HashSet<string>(StringComparer.Ordinal);
                var result = new List<TypeModel>(
                    fromNinoTypes.Length + fromGenericCalls.Length + fromStatements.Length);

                foreach (var model in fromNinoTypes)
                {
                    if (seen.Add(model.DisplayString))
                        result.Add(model);
                }

                foreach (var model in fromGenericCalls)
                {
                    if (seen.Add(model.DisplayString))
                        result.Add(model);
                }

                foreach (var model in fromStatements)
                {
                    if (seen.Add(model.DisplayString))
                        result.Add(model);
                }

                return result;
            })
            .WithTrackingName("Tier2_AllExpandedTypes");

        context.RegisterSourceOutput(allExpandedTypes, GenerateForType);
    }

    /// <summary>
    /// Deduplicates a collection of TypeModels by DisplayString.
    /// Uses capacity hint to avoid List resizing.
    /// </summary>
    private static EquatableArray<TypeModel> DeduplicateTypes(ImmutableArray<TypeModel> types)
    {
        var seen = new HashSet<string>(StringComparer.Ordinal);
        var result = new List<TypeModel>(types.Length);
        foreach (var model in types)
        {
            if (seen.Add(model.DisplayString))
                result.Add(model);
        }
        return new EquatableArray<TypeModel>(result.ToArray());
    }

    /// <summary>
    /// Extracts all types from a type symbol recursively.
    /// Outputs:
    /// - Constructed generic NinoTypes (e.g., Foo&lt;int&gt; where Foo&lt;T&gt; has [NinoType])
    /// - All non-NinoTypes (primitives, system types, etc.)
    /// Skips:
    /// - Non-constructed NinoTypes (handled by Tier 1)
    /// - Open generics (contain type parameters)
    /// </summary>
    private static void ExtractAllTypes(ITypeSymbol typeSymbol, List<TypeModel> results, CancellationToken ct)
    {
        var toProcess = RentTypeStack();
        var processed = RentStringSet();

        try
        {
            toProcess.Push(typeSymbol);

            while (toProcess.Count > 0)
            {
                ct.ThrowIfCancellationRequested();
                var current = toProcess.Pop();

                // Skip type parameters
                if (current.TypeKind == TypeKind.TypeParameter)
                    continue;

                // Skip open generics - we only want closed types
                // Pass our stack to avoid nested allocation
                if (ContainsTypeParameter(current, toProcess))
                    continue;

                // Normalize type to eliminate duplicates:
                // - Remove nullable annotations (string? -> string)
                // - Normalize tuples to ignore field names ((int a, string b) -> ValueTuple<int, string>)
                var normalizedType = current.GetPureType().GetNormalizedTypeSymbol();

                // Create TypeModel early to get normalized display string for deduplication
                var typeModel = new TypeModel(current);
                if (!processed.Add(typeModel.DisplayString))
                    continue;

                // Determine if this type should be output
                var isNinoType = IsNinoType(normalizedType);
                var isConstructedGeneric = normalizedType is INamedTypeSymbol { IsGenericType: true } namedType &&
                    !SymbolEqualityComparer.Default.Equals(namedType.OriginalDefinition, namedType);

                if (isNinoType)
                {
                    // Only output constructed generic NinoTypes (e.g., Foo<int>)
                    // Non-constructed NinoTypes (e.g., Foo, Bar<T>) are handled by Tier 1
                    if (isConstructedGeneric)
                    {
                        results.Add(typeModel);
                    }
                }
                else
                {
                    // Output all non-NinoTypes
                    results.Add(typeModel);
                }

                // Recurse into child types (arrays, generics)
                switch (current)
                {
                    case IArrayTypeSymbol arrayType:
                        toProcess.Push(arrayType.ElementType);
                        break;
                    case INamedTypeSymbol { IsGenericType: true } genericType:
                        foreach (var typeArg in genericType.TypeArguments)
                            toProcess.Push(typeArg);
                        break;
                }
            }
        }
        finally
        {
            ReturnTypeStack(toProcess);
            ReturnStringSet(processed);
        }
    }

    /// <summary>
    /// Gets member types (fields and properties) from a type symbol.
    /// Only includes properties with both getter and setter (serializable properties).
    /// </summary>
    private static IEnumerable<ITypeSymbol> GetMemberTypes(INamedTypeSymbol symbol)
    {
        foreach (var member in symbol.GetMembers())
        {
            if (member.IsImplicitlyDeclared || member.IsStatic)
                continue;

            ITypeSymbol? memberType = member switch
            {
                IFieldSymbol field => field.Type,
                // Only include properties with both getter and setter
                IPropertySymbol { GetMethod: not null, SetMethod: not null } prop => prop.Type,
                _ => null
            };

            if (memberType != null)
                yield return memberType;
        }
    }

    /// <summary>
    /// Generates output for a single type.
    /// One file per type ensures small, focused files that minimize recompilation scope.
    /// When a type changes, only its specific file needs recompilation.
    /// </summary>
    private static void GenerateForType(SourceProductionContext spc, TypeModel typeModel)
    {
        var safeFileName = GetSafeFileName(typeModel.DisplayString);
        var source = GenerateTypeSource(typeModel);
        spc.AddSource($"NinoType_{safeFileName}.g.cs", source);

        // Future: If adding diagnostics, emit them separately to avoid invalidating cached source
        // Future: If generating multiple artifacts per type, each should be a separate AddSource call
    }

    /// <summary>
    /// Generates source code for a type. Currently generates a comment placeholder.
    /// When implementing actual code generation, use ExcludeFromCodeCoverage attribute.
    /// </summary>
    private static string GenerateTypeSource(TypeModel typeModel)
    {
        return $"""
            // <auto-generated/>
            // Type: {typeModel.DisplayString}
            // Generated by {GeneratorName} v{GeneratorVersion}

            // When adding generated types/methods, include:
            // [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
            // [System.CodeDom.Compiler.GeneratedCode("{GeneratorName}", "{GeneratorVersion}")]
            """;
    }

    /// <summary>
    /// Converts a type display string to a safe file name.
    /// Uses distinct replacement characters for type modifiers to avoid collisions.
    /// Uses Span with stackalloc for short strings to minimize allocations.
    /// </summary>
    private static unsafe string GetSafeFileName(string displayString)
    {
        var length = displayString.Length;

        // Use stackalloc for strings under 512 chars, heap allocation for longer ones
        Span<char> chars = length <= 512 ? stackalloc char[length] : new char[length];

        for (int i = 0; i < length; i++)
        {
            var c = displayString[i];
            chars[i] = c switch
            {
                '<' => 'L',  // Left angle bracket (generic) - distinct from '>'
                '>' => 'R',  // Right angle bracket (generic)
                '[' => 'A',  // Array
                ']' => 'A',
                '?' => 'N',  // Nullable
                '*' => 'P',  // Pointer
                ',' => 'C',  // Comma (generic separator)
                ' ' => '_',  // Space
                '.' => '_',  // Dot (namespace separator)
                _ => char.IsLetterOrDigit(c) ? c : '_'
            };
        }

        // Use fixed to get pointer from span and create string without extra allocation
        fixed (char* ptr = chars)
        {
            return new string(ptr, 0, length);
        }
    }

    #region Data Models with Structural Equality

    /// <summary>
    /// Model representing a discovered type.
    /// Automatically normalizes types to eliminate duplicates:
    /// - Removes nullable annotations (string? -> string)
    /// - Normalizes tuples to ignore field names ((int a, string b) -> ValueTuple&lt;int, string&gt;)
    /// Provides automatic IEquatable implementation for incremental caching.
    /// </summary>
    private readonly record struct TypeModel
    {
        public string DisplayString { get; }

        public TypeModel(ITypeSymbol typeSymbol)
        {
            var normalized = typeSymbol.GetPureType().GetNormalizedTypeSymbol();
            DisplayString = normalized.ToDisplayString();
        }
    }

    /// <summary>
    /// An immutable array wrapper with structural equality for incremental generator caching.
    /// Standard ImmutableArray only checks reference equality of the underlying array,
    /// which breaks caching. This wrapper compares contents using SequenceEqual.
    /// Hash code is cached at construction time to avoid repeated computation.
    /// </summary>
    /// <typeparam name="T">Element type that must implement IEquatable{T}.</typeparam>
    private readonly struct EquatableArray<T> : IEquatable<EquatableArray<T>>, IEnumerable<T>
        where T : IEquatable<T>
    {
        private readonly T[]? _array;
        private readonly int _hashCode;

        public EquatableArray(T[] array)
        {
            _array = array;
            _hashCode = ComputeHashCode(array);
        }

        public ReadOnlySpan<T> AsSpan() => _array.AsSpan();

        public int Length => _array?.Length ?? 0;

        public bool Equals(EquatableArray<T> other)
        {
            // Fast path: if hash codes differ, arrays are definitely different
            if (_hashCode != other._hashCode)
                return false;
            // Fast path: if lengths differ, arrays are definitely different
            if (Length != other.Length)
                return false;
            return AsSpan().SequenceEqual(other.AsSpan());
        }

        public override bool Equals(object? obj) => obj is EquatableArray<T> other && Equals(other);

        public override int GetHashCode() => _hashCode;

        private static int ComputeHashCode(T[]? array)
        {
            if (array == null) return 0;

            // Use unchecked for overflow wrapping (standard hash behavior)
            unchecked
            {
                int hash = 17;
                foreach (var item in array)
                {
                    hash = hash * 31 + item.GetHashCode();
                }
                return hash;
            }
        }

        public static bool operator ==(EquatableArray<T> left, EquatableArray<T> right) => left.Equals(right);
        public static bool operator !=(EquatableArray<T> left, EquatableArray<T> right) => !left.Equals(right);

        // IEnumerable implementation - used by SelectMany in the pipeline
        public IEnumerator<T> GetEnumerator() => ((IEnumerable<T>)(_array ?? Array.Empty<T>())).GetEnumerator();
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
    }

    #endregion

    /// <summary>
    /// Checks if a type symbol contains any type parameters (is an open generic).
    /// Uses iterative approach to avoid stack overflow on deeply nested generics.
    /// Uses object pooling to minimize allocations.
    /// </summary>
    /// <param name="typeSymbol">The type symbol to check</param>
    /// <param name="reusableStack">Optional pre-rented stack to reuse, avoiding nested allocations</param>
    private static bool ContainsTypeParameter(ITypeSymbol typeSymbol, Stack<ITypeSymbol>? reusableStack = null)
    {
        // Fast path for common case
        if (typeSymbol.TypeKind == TypeKind.TypeParameter)
            return true;

        // Fast path for simple non-generic types
        if (typeSymbol is not IArrayTypeSymbol && typeSymbol is not INamedTypeSymbol { IsGenericType: true })
            return false;

        // Use provided stack or rent a new one
        var toCheck = reusableStack ?? RentTypeStack();
        var shouldReturn = reusableStack == null;
        var initialCount = toCheck.Count;

        try
        {
            toCheck.Push(typeSymbol);

            while (toCheck.Count > initialCount)
            {
                var current = toCheck.Pop();

                if (current.TypeKind == TypeKind.TypeParameter)
                    return true;

                switch (current)
                {
                    case IArrayTypeSymbol arrayType:
                        toCheck.Push(arrayType.ElementType);
                        break;
                    case INamedTypeSymbol { IsGenericType: true } namedType:
                        foreach (var typeArg in namedType.TypeArguments)
                            toCheck.Push(typeArg);
                        break;
                }
            }

            return false;
        }
        finally
        {
            // Clean up items we added to the stack
            while (toCheck.Count > initialCount)
                toCheck.Pop();

            // Only return to pool if we rented it (not reusing caller's stack)
            if (shouldReturn)
                ReturnTypeStack(toCheck);
        }
    }

    /// <summary>
    /// Checks if a type is a NinoType (has attribute or inherits from one with allowInheritance=true).
    /// Optimized to avoid redundant attribute lookups and minimize AllInterfaces enumeration.
    /// </summary>
    private static bool IsNinoType(ITypeSymbol typeSymbol)
    {
        // Check direct attribute
        if (HasNinoTypeAttribute(typeSymbol))
            return true;

        // Check base type chain
        var baseType = typeSymbol.BaseType;
        while (baseType != null)
        {
            var (hasAttr, allowInheritance) = GetNinoTypeAttributeInfo(baseType);
            if (hasAttr)
                return allowInheritance;

            baseType = baseType.BaseType;
        }

        // Check interfaces - early exit on first match
        // Common case: types have 0-3 interfaces, so full enumeration is fast
        // AllInterfaces returns ImmutableArray, allocation already happened
        var interfaces = typeSymbol.AllInterfaces;
        if (interfaces.Length == 0)
            return false;

        foreach (var interfaceType in interfaces)
        {
            var (hasAttr, allowInheritance) = GetNinoTypeAttributeInfo(interfaceType);
            if (hasAttr && allowInheritance)
                return true;
        }

        return false;
    }

    /// <summary>
    /// Checks if a type has the NinoTypeAttribute.
    /// Uses full name comparison for correctness across namespaces.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static bool HasNinoTypeAttribute(ITypeSymbol typeSymbol)
    {
        foreach (var attr in typeSymbol.GetAttributes())
        {
            if (IsNinoTypeAttribute(attr.AttributeClass))
                return true;
        }
        return false;
    }

    /// <summary>
    /// Gets NinoTypeAttribute info in a single pass - returns (hasAttribute, allowInheritance).
    /// Avoids calling GetAttributes() twice when we need both pieces of info.
    /// </summary>
    private static (bool HasAttribute, bool AllowInheritance) GetNinoTypeAttributeInfo(ITypeSymbol typeSymbol)
    {
        foreach (var attr in typeSymbol.GetAttributes())
        {
            if (IsNinoTypeAttribute(attr.AttributeClass))
            {
                var allowInheritance = NinoTypeHelper.GetConstructorArgumentByName(attr, "allowInheritance", true);
                return (true, allowInheritance);
            }
        }
        return (false, false);
    }

    /// <summary>
    /// Checks if a symbol is the NinoTypeAttribute type.
    /// Uses fast name check first, then full name for correctness.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static bool IsNinoTypeAttribute(INamedTypeSymbol? attributeClass)
    {
        if (attributeClass == null)
            return false;
        // Fast path: check simple name first (avoids ToDisplayString in most cases)
        if (attributeClass.Name != NinoTypeAttributeName)
            return false;
        // Full check: verify the complete qualified name
        return attributeClass.ToDisplayString() == NinoTypeAttributeFullName;
    }

    /// <summary>
    /// Checks if a syntax node is inside an executable context (method body, property accessor, etc.)
    /// rather than a class-level type declaration (field type, property type, base list, etc.).
    /// Optimized with fast-path checks and minimal parent traversal.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static bool IsInExecutableContext(SyntaxNode node)
    {
        var current = node.Parent;

        // Limit traversal depth as most executable contexts are within 10 levels
        // This prevents excessive walking in deeply nested syntax trees
        var depth = 0;
        const int maxDepth = 15;

        while (current != null && depth < maxDepth)
        {
            switch (current)
            {
                // Executable contexts - we want these
                case MethodDeclarationSyntax:
                case ConstructorDeclarationSyntax:
                case AccessorDeclarationSyntax:
                case LocalFunctionStatementSyntax:
                case LambdaExpressionSyntax:
                case AnonymousMethodExpressionSyntax:
                    return true;

                // Type declaration level - not executable context (most common stop case)
                case TypeDeclarationSyntax:
                    return false;

                // Namespace or compilation unit - definitely not executable
                case NamespaceDeclarationSyntax:
                case CompilationUnitSyntax:
                    return false;
            }

            current = current.Parent;
            depth++;
        }

        return false;
    }
}
