using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Nino.Generator.Metadata;

namespace Nino.Generator.Common;

public partial class DeserializerGenerator
{
    #region Main Generation Entry Point

    private void GenerateTrivialCode(SourceProductionContext spc, HashSet<ITypeSymbol> generatedTypes)
    {
        var compilation = Compilation;
        var sb = new StringBuilder();
        sb.GenerateClassDeserializeMethods("string");
        HashSet<string> generatedTypeNames = new();

        foreach (var ninoType in NinoTypes)
        {
            try
            {
                if (!generatedTypes.Add(ninoType.TypeSymbol))
                    continue;
                if (!generatedTypeNames.Add(ninoType.TypeSymbol.GetDisplayString()))
                    continue;
                if (!ninoType.TypeSymbol.IsInstanceType() || !string.IsNullOrEmpty(ninoType.CustomDeserializer))
                    continue;

                sb.AppendLine();
                GenerateDeserializerMethod(sb, ninoType, false); // out version
                sb.AppendLine();
                GenerateDeserializerMethod(sb, ninoType, true); // ref version
                sb.AppendLine();
            }
            catch (Exception e)
            {
                sb.AppendLine($"/* Error: {e.Message} for type {ninoType.TypeSymbol.GetTypeFullName()} */");
            }
        }

        var curNamespace = compilation.AssemblyName!.GetNamespace();
        var globalCustomFormatters = CollectGlobalCustomFormatters();
        var staticFormatterFields = GenerateStaticFormatterFields(globalCustomFormatters);

        var code = $$"""
                     // <auto-generated/>
                     using System;
                     using global::Nino.Core;
                     using System.Buffers;
                     using System.ComponentModel;
                     using System.Collections.Generic;
                     using System.Collections.Concurrent;
                     using System.Runtime.InteropServices;
                     using System.Runtime.CompilerServices;

                     namespace {{curNamespace}}
                     {
                         public static partial class Deserializer
                         {{{staticFormatterFields}}
                     {{GeneratePrivateDeserializeImplMethodBody("string", "        ")}}
                             
                     {{sb}}
                         }
                     }
                     """;

        spc.AddSource($"{curNamespace}.Deserializer.g.cs", code);
    }

    #endregion

    #region Core Method Generation

    private void GenerateDeserializerMethod(StringBuilder sb, NinoType ninoType, bool byRef)
    {
        string decl = byRef ? "ref" : "out";
        string suffix = byRef ? "Ref" : "";

        sb.AppendLine();
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine($"        public static void DeserializeImpl{suffix}({decl} {ninoType.TypeSymbol.GetTypeFullName()} value, ref Reader reader)");
        sb.AppendLine("        {");
        sb.AppendLine($"        #if {NinoTypeHelper.WeakVersionToleranceSymbol}");
        sb.AppendLine("           if (reader.Eof)");
        sb.AppendLine("           {");
        sb.AppendLine("              value = default;");
        sb.AppendLine("              return;");
        sb.AppendLine("           }");
        sb.AppendLine("        #endif");

        // Add null reference safety for ref parameters - fallback to out implementation
        if (byRef)
        {
            sb.AppendLine("            if (Unsafe.IsNullRef(ref value))");
            sb.AppendLine("            {");
            sb.AppendLine($"                DeserializeImpl(out value, ref reader);");
            sb.AppendLine("                return;");
            sb.AppendLine("            }");
            sb.AppendLine();
        }

        if (ninoType.IsPolymorphic())
        {
            sb.AppendLine("            reader.Read(out int typeId);");
            sb.AppendLine("            if(typeId == TypeCollector.Null)");
            sb.AppendLine("            {");
            sb.AppendLine("                value = default;");
            sb.AppendLine("                return;");
            sb.AppendLine("            }");
            sb.AppendLine(
                $"            else if(typeId != NinoTypeConst.{ninoType.TypeSymbol.GetTypeFullName().GetTypeConstName()})");
            sb.AppendLine("                throw new InvalidOperationException(\"Invalid type id\");");
            sb.AppendLine();
        }

        if (ninoType.TypeSymbol.IsUnmanagedType)
        {
            // Even for unmanaged types, we need version tolerance
            sb.AppendLine($"#if {NinoTypeHelper.WeakVersionToleranceSymbol}");
            sb.AppendLine("            if (!reader.Eof)");
            sb.AppendLine("            {");
            sb.AppendLine("                reader.UnsafeRead(out value);");
            sb.AppendLine("            }");
            sb.AppendLine("            else");
            sb.AppendLine("            {");
            sb.AppendLine("                value = default;");
            sb.AppendLine("            }");
            sb.AppendLine("#else");
            sb.AppendLine("            reader.UnsafeRead(out value);");
            sb.AppendLine("#endif");
        }
        else
        {
            GenerateComplexTypeDeserialization(sb, ninoType, byRef);
        }

        sb.AppendLine("        }");
    }

    private void GenerateComplexTypeDeserialization(StringBuilder sb, NinoType ninoType, bool byRef)
    {
        var members = ninoType.Members.ToList();

        // Generate deserializer declarations upfront
        var neededDeserializers = GetNeededDeserializers(members);
        foreach (var kvp in neededDeserializers)
        {
            sb.AppendLine($"            var {kvp.Value} = CachedDeserializer<{kvp.Key.GetDisplayString()}>.Instance;");
        }

        // Determine which members are handled by constructor
        var constructorHandledMembers = GetConstructorHandledMembers(ninoType);

        // Create instance if needed
        if (!byRef)
        {
            CreateInstance(sb, ninoType, neededDeserializers, byRef);
        }

        // Deserialize ALL members to maintain stream alignment, but only assign assignable ones
        foreach (var member in members)
        {
            if (!member.IsCtorParameter && !constructorHandledMembers.Contains(member.Name))
            {
                // Can assign this member
                GenerateMemberDeserialization(sb, member, ninoType, neededDeserializers, byRef);
            }
            else if (!constructorHandledMembers.Contains(member.Name))
            {
                // Must read from stream but cannot assign (e.g., init-only properties)
                GenerateDiscardDeserialization(sb, member, neededDeserializers, byRef);
            }
        }
    }

    #endregion

    #region Member Deserialization

    private void GenerateDiscardDeserialization(StringBuilder sb, NinoMember member,
        Dictionary<ITypeSymbol, string> neededDeserializers, bool byRef)
    {
        // Read from stream but discard the value (for init-only properties when using parameterless constructor)
        var tempVar = $"temp_{member.Name}";
        var type = member.Type;

        // Generate temporary variable declaration and read statement
        sb.AppendLine($"            {type.GetDisplayString()} {tempVar};");
        var readStatement = GenerateReadStatement(member, tempVar, neededDeserializers, byRef);
        sb.AppendLine($"            {readStatement}");
        sb.AppendLine($"            // Discarded {tempVar} (cannot assign to init-only property)");
    }

    private void GenerateMemberDeserialization(StringBuilder sb, NinoMember member, NinoType parentType,
        Dictionary<ITypeSymbol, string> deserializers, bool byRef)
    {
        var memberAccess = GetMemberAccess(member);

        if (member.IsPrivate)
        {
            // Special handling for private members
            var tempVar = $"temp_{member.Name}";
            sb.AppendLine($"            {member.Type.GetDisplayString()} {tempVar} = default;");
            var readStatement = GenerateReadStatement(member, tempVar, deserializers, byRef);

            // Version tolerance wrapper
            sb.AppendLine($"#if {NinoTypeHelper.WeakVersionToleranceSymbol}");
            sb.AppendLine($"            if (!reader.Eof)");
            sb.AppendLine("            {");
            sb.AppendLine($"                {readStatement}");
            sb.AppendLine("            }");
            sb.AppendLine("#else");
            sb.AppendLine($"            {readStatement}");
            sb.AppendLine("#endif");

            // Assign the value using appropriate method
            if (member.IsProperty)
            {
                sb.AppendLine("#if NET8_0_OR_GREATER");
                sb.AppendLine(
                    $"            PrivateAccessor.__set__{member.Name}__({(parentType.TypeSymbol.IsValueType ? "ref value" : "value")}, {tempVar});");
                sb.AppendLine("#else");
                sb.AppendLine($"            value.__nino__generated__{member.Name} = {tempVar};");
                sb.AppendLine("#endif");
            }
            else
            {
                sb.AppendLine("#if NET8_0_OR_GREATER");
                sb.AppendLine(
                    $"            ref var __ref_{member.Name} = ref PrivateAccessor.__{member.Name}__({(parentType.TypeSymbol.IsValueType ? "ref value" : "value")});");
                sb.AppendLine($"            __ref_{member.Name} = {tempVar};");
                sb.AppendLine("#else");
                sb.AppendLine($"            value.__nino__generated__{member.Name} = {tempVar};");
                sb.AppendLine("#endif");
            }
        }
        else if (member.IsProperty)
        {
            // Properties need temp variable
            var tempVar = $"temp_{member.Name}";
            sb.AppendLine($"            {member.Type.GetDisplayString()} {tempVar} = default;");
            var readStatement = GenerateReadStatement(member, tempVar, deserializers, byRef);

            // Simple version tolerance wrapper
            sb.AppendLine($"#if {NinoTypeHelper.WeakVersionToleranceSymbol}");
            sb.AppendLine($"            if (!reader.Eof)");
            sb.AppendLine("            {");
            sb.AppendLine($"                {readStatement}");
            sb.AppendLine($"                {memberAccess} = {tempVar};");
            sb.AppendLine("            }");
            sb.AppendLine("#else");
            sb.AppendLine($"            {readStatement}");
            sb.AppendLine($"            {memberAccess} = {tempVar};");
            sb.AppendLine("#endif");
        }
        else
        {
            // Fields can be accessed directly
            var readStatement = GenerateReadStatement(member, memberAccess, deserializers, byRef);

            // Simple version tolerance wrapper
            sb.AppendLine($"#if {NinoTypeHelper.WeakVersionToleranceSymbol}");
            sb.AppendLine($"            if (!reader.Eof) {readStatement}");
            sb.AppendLine("#else");
            sb.AppendLine($"            {readStatement}");
            sb.AppendLine("#endif");
        }
    }

    private string GetMemberAccess(NinoMember member)
    {
        if (member.IsPrivate)
        {
            // Return a placeholder for private members - we'll handle them specially in the calling code
            return "__private__";
        }

        return $"value.{member.Name}";
    }

    private string GenerateReadStatement(NinoMember member, string memberAccess,
        Dictionary<ITypeSymbol, string> deserializers, bool isRefScenario = false)
    {
        var type = member.Type;

        // Priority 1: Custom formatters
        if (member.HasCustomFormatter())
        {
            var formatterType = member.CustomFormatterType();
            if (formatterType != null)
            {
                var formatterVar = formatterType.GetCachedVariableName("formatter");
                return $"{formatterVar}.Deserialize(out {memberAccess}, ref reader);";
            }
        }

        // Priority 2: Unmanaged types
        if (type.IsUnmanagedType && !IsPolymorphicType(type))
        {
            return $"reader.UnsafeRead(out {memberAccess});";
        }

        // Priority 3: Strings (UTF8/UTF16)
        if (type.SpecialType == SpecialType.System_String)
        {
            var method = member.IsUtf8String ? "ReadUtf8" : "Read";
            return $"reader.{method}(out {memberAccess});";
        }

        // Priority 4: Object type - use polymorphic deserialization with null type
        if (type.SpecialType == SpecialType.System_Object)
        {
            if (isRefScenario)
            {
                return $"NinoDeserializer.DeserializeRefBoxed(ref {memberAccess}, ref reader, null);";
            }
            else
            {
                return $"{memberAccess} = NinoDeserializer.DeserializeBoxed(ref reader, null);";
            }
        }

        // Priority 5: Complex types with cached deserializers
        if (deserializers.TryGetValue(type, out var deserializerVar))
        {
            return $"{deserializerVar}.Deserialize(out {memberAccess}, ref reader);";
        }

        return $"// Unable to deserialize {memberAccess}";
    }

    #endregion

    #region Instance Creation

    private void CreateInstance(StringBuilder sb, NinoType ninoType, Dictionary<ITypeSymbol, string> neededDeserializers, bool byRef)
    {
        var constructors = (ninoType.TypeSymbol as INamedTypeSymbol)?.Constructors.ToList() ??
                           new List<IMethodSymbol>();

        // Add static factory methods
        constructors.AddRange(ninoType.TypeSymbol.GetMembers().OfType<IMethodSymbol>()
            .Where(m => m.DeclaredAccessibility == Accessibility.Public &&
                        m.IsStatic &&
                        SymbolEqualityComparer.Default.Equals(m.ReturnType, ninoType.TypeSymbol)));

        var constructor = FindBestConstructor(constructors, ninoType);

        if (constructor is null)
        {
            sb.AppendLine(
                $"            throw new InvalidOperationException(\"No constructor found for {ninoType.TypeSymbol.GetDisplayString()}\");");
            return;
        }

        if (constructor.Parameters.Length == 0)
        {
            var ctorCall = constructor.MethodKind == MethodKind.Constructor
                ? $"new {ninoType.TypeSymbol.GetDisplayString()}()"
                : $"{ninoType.TypeSymbol.GetDisplayString()}.{constructor.Name}()";
            sb.AppendLine($"            value = {ctorCall};");
        }
        else
        {
            // For constructors with parameters, we need to deserialize constructor args first
            GenerateConstructorWithParameters(sb, ninoType, constructor, neededDeserializers, byRef);
        }
    }

    private IMethodSymbol? FindBestConstructor(List<IMethodSymbol> constructors, NinoType ninoType)
    {
        // Look for NinoConstructor attribute first
        var customCtor = constructors.FirstOrDefault(c => c.GetAttributesCache()
            .Any(a => a.AttributeClass?.GetDisplayString().EndsWith("NinoConstructorAttribute") == true));
        if (customCtor != null) return customCtor;

        // For records, try to find primary constructor
        if (ninoType.TypeSymbol.IsRecord)
        {
            var primaryCtor = constructors.FirstOrDefault(c => c.Parameters.All(p =>
                ninoType.Members.Any(m => m.Name == p.Name)));
            if (primaryCtor != null) return primaryCtor;
        }

        // Default: shortest constructor
        return constructors.OrderBy(c => c.Parameters.Length).FirstOrDefault();
    }

    private void GenerateConstructorWithParameters(StringBuilder sb, NinoType ninoType, IMethodSymbol constructor, Dictionary<ITypeSymbol, string> neededDeserializers, bool byRef)
    {
        // Get constructor attribute to find parameter name mapping
        var constructorAttr = constructor.GetAttributesCache()
            .FirstOrDefault(a => a.AttributeClass?.GetDisplayString().EndsWith("NinoConstructorAttribute") == true);

        var parameters = constructor.Parameters;
        var paramVars = new List<string>();

        if (constructorAttr != null && constructorAttr.ConstructorArguments.Length > 0)
        {
            // Use mapped parameter names from NinoConstructor attribute
            List<string> memberNames = new();
            foreach (var arg in constructorAttr.ConstructorArguments)
            {
                if (arg.Kind == TypedConstantKind.Array)
                {
                    foreach (var item in arg.Values)
                    {
                        if (item.Value is string str && !string.IsNullOrEmpty(str))
                        {
                            memberNames.Add(str);
                        }
                    }
                }
                else if (arg.Value is string str && !string.IsNullOrEmpty(str))
                {
                    memberNames.Add(str);
                }
            }

            for (int i = 0; i < parameters.Length && i < memberNames.Count; i++)
            {
                var param = parameters[i];
                var memberName = memberNames[i];
                var paramVar = $"param_{param.Name}";
                paramVars.Add(paramVar);

                // Find the member by name to get proper deserialization
                var member = ninoType.Members.FirstOrDefault(m => m.Name == memberName);
                if (member != null)
                {
                    sb.AppendLine($"            {param.Type.GetDisplayString()} {paramVar};");
                    var readStatement = GenerateReadStatement(member, paramVar, neededDeserializers, byRef);
                    sb.AppendLine($"            {readStatement}");
                }
                else
                {
                    // Fallback: basic read
                    sb.AppendLine($"            {param.Type.GetDisplayString()} {paramVar};");
                    sb.AppendLine($"            reader.Read(out {paramVar});");
                }
            }
        }
        else
        {
            // No attribute mapping, but for records we need to order parameters by serialization order (NinoMember indices)
            if (ninoType.TypeSymbol.IsRecord)
            {
                // For records, read parameters in serialization order but keep constructor order for the call
                var constructorParamVars = new Dictionary<string, string>();

                // Read parameters in serialization order (NinoMember index order)
                foreach (var member in ninoType.Members.Where(m => m.IsCtorParameter))
                {
                    var param = parameters.FirstOrDefault(p => p.Name == member.Name);
                    if (param != null)
                    {
                        var paramVar = $"param_{param.Name}";
                        constructorParamVars[param.Name] = paramVar;

                        sb.AppendLine($"            {param.Type.GetDisplayString()} {paramVar};");
                        var readStatement =
                            GenerateReadStatement(member, paramVar, neededDeserializers, byRef);
                        sb.AppendLine($"            {readStatement}");
                    }
                }

                // Add parameter variables in constructor declaration order
                foreach (var param in parameters)
                {
                    if (constructorParamVars.TryGetValue(param.Name, out var paramVar))
                    {
                        paramVars.Add(paramVar);
                    }
                }
            }
            else
            {
                // For non-records, use parameter order
                foreach (var param in parameters)
                {
                    var paramVar = $"param_{param.Name}";
                    paramVars.Add(paramVar);

                    sb.AppendLine($"            {param.Type.GetDisplayString()} {paramVar};");
                    sb.AppendLine($"            reader.Read(out {paramVar});");
                }
            }
        }

        var ctorCall = constructor.MethodKind == MethodKind.Constructor
            ? $"new {ninoType.TypeSymbol.GetDisplayString()}({string.Join(", ", paramVars)})"
            : $"{ninoType.TypeSymbol.GetDisplayString()}.{constructor.Name}({string.Join(", ", paramVars)})";

        sb.AppendLine($"            value = {ctorCall};");
    }

    #endregion

    #region Helper Methods

    private HashSet<string> GetConstructorHandledMembers(NinoType ninoType)
    {
        var handledMembers = new HashSet<string>();

        var constructors = (ninoType.TypeSymbol as INamedTypeSymbol)?.Constructors.ToList() ??
                           new List<IMethodSymbol>();

        // Add static factory methods
        constructors.AddRange(ninoType.TypeSymbol.GetMembers().OfType<IMethodSymbol>()
            .Where(m => m.DeclaredAccessibility == Accessibility.Public &&
                        m.IsStatic &&
                        SymbolEqualityComparer.Default.Equals(m.ReturnType, ninoType.TypeSymbol)));

        var constructor = FindBestConstructor(constructors, ninoType);

        if (constructor?.Parameters.Length > 0)
        {
            var constructorAttr = constructor.GetAttributesCache()
                .FirstOrDefault(a => a.AttributeClass?.GetDisplayString().EndsWith("NinoConstructorAttribute") == true);

            if (constructorAttr != null && constructorAttr.ConstructorArguments.Length > 0)
            {
                // Get member names from NinoConstructor attribute
                foreach (var arg in constructorAttr.ConstructorArguments)
                {
                    if (arg.Kind == TypedConstantKind.Array)
                    {
                        foreach (var item in arg.Values)
                        {
                            if (item.Value is string str && !string.IsNullOrEmpty(str))
                            {
                                handledMembers.Add(str);
                            }
                        }
                    }
                    else if (arg.Value is string str && !string.IsNullOrEmpty(str))
                    {
                        handledMembers.Add(str);
                    }
                }
            }
            else if (ninoType.TypeSymbol.IsRecord)
            {
                // For records, primary constructor parameters map to properties
                foreach (var param in constructor.Parameters)
                {
                    handledMembers.Add(param.Name);
                }
            }
        }

        return handledMembers;
    }

    private Dictionary<ITypeSymbol, string> GetNeededDeserializers(List<NinoMember> members)
    {
        var deserializers = new Dictionary<ITypeSymbol, string>(SymbolEqualityComparer.Default);

        foreach (var member in members)
        {
            var type = member.Type;
            if (!member.IsCtorParameter &&
                !member.HasCustomFormatter() &&
                type.SpecialType != SpecialType.System_String &&
                !type.IsUnmanagedType &&
                !deserializers.ContainsKey(type))
            {
                deserializers[type] = type.GetCachedVariableName("deserializer");
            }
        }

        return deserializers;
    }

    private bool IsPolymorphicType(ITypeSymbol type)
    {
        return NinoGraph.TypeMap.TryGetValue(type.GetDisplayString(), out var ninoType) && ninoType.IsPolymorphic();
    }

    private Dictionary<string, (ITypeSymbol FormatterType, ITypeSymbol ValueType)> CollectGlobalCustomFormatters()
    {
        var formatters = new Dictionary<string, (ITypeSymbol FormatterType, ITypeSymbol ValueType)>();

        foreach (var ninoType in NinoTypes)
        {
            foreach (var member in ninoType.Members)
            {
                if (member.HasCustomFormatter())
                {
                    var formatterType = member.CustomFormatterType();
                    if (formatterType != null)
                    {
                        var key = $"{formatterType.GetDisplayString()}_{member.Type.GetDisplayString()}";
                        formatters[key] = (formatterType, member.Type);
                    }
                }
            }
        }

        return formatters;
    }

    private string GenerateStaticFormatterFields(
        Dictionary<string, (ITypeSymbol FormatterType, ITypeSymbol ValueType)> formatters)
    {
        if (formatters.Count == 0) return "";

        var sb = new StringBuilder();
        sb.AppendLine();
        sb.AppendLine("        // Static formatter fields for optimal performance");

        foreach (var kvp in formatters)
        {
            var formatterType = kvp.Value.FormatterType;
            var valueType = kvp.Value.ValueType;
            var varName = formatterType.GetCachedVariableName("formatter");
            sb.AppendLine(
                $"        private static readonly {formatterType.GetDisplayString()} {varName} = NinoFormatterInstance<{formatterType.GetDisplayString()}, {valueType.GetDisplayString()}>.Instance;");
        }

        return sb.ToString();
    }

    private static string GeneratePrivateDeserializeImplMethodBody(string typeName, string indent = "")
    {
        var ret = $$"""
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    public static void Deserialize(out {{typeName}} value, ref Reader reader)
                    {
                    #if {{NinoTypeHelper.WeakVersionToleranceSymbol}}
                         if (reader.Eof)
                         {
                            value = default;
                            return;
                         }
                    #endif
                        
                        reader.Read(out value);
                    }

                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    public static void DeserializeRef(ref {{typeName}} value, ref Reader reader)
                    {
                    #if {{NinoTypeHelper.WeakVersionToleranceSymbol}}
                         if (reader.Eof)
                         {
                            value = default;
                            return;
                         }
                    #endif
                        
                        reader.Read(out value);
                    }
                    """;

        ret = ret.Replace("\n", $"\n{indent}");
        return $"{indent}{ret}";
    }

    #endregion
}