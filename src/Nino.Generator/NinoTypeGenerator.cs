using System;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using System.Collections.Generic;
using System.Collections.Immutable;
using Microsoft.CodeAnalysis.CSharp;

namespace Nino.Generator;

[Generator]
public class NinoTypeGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var types = context.GetTypeSyntaxes();
        var compilationAndClasses = context.CompilationProvider.Combine(types.Collect());
        context.RegisterSourceOutput(compilationAndClasses, (spc, source) => Execute(source.Left, source.Right, spc));
    }

    private static void Execute(Compilation compilation, ImmutableArray<CSharpSyntaxNode> syntaxes,
        SourceProductionContext spc)
    {
        var result = compilation.IsValidCompilation();
        if (!result.isValid) return;
        compilation = result.newCompilation;

        var ninoSymbols = syntaxes.GetNinoTypeSymbols(compilation);

        // get type full names from models (namespaces + type names)
        var serializableTypes = ninoSymbols
            .Where(symbol => symbol.IsPolymorphicType())
            .Where(symbol => symbol.IsInstanceType());

        var types = new StringBuilder();
        foreach (var type in serializableTypes)
        {
            string variableName = type.GetTypeFullName().GetTypeConstName();
            types.AppendLine($"\t\t// {type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}");
            types.AppendLine($"\t\tpublic const int {variableName} = {type.GetId()};");
        }

        //remove last newline
        types.Remove(types.Length - 1, 1);

        var curNamespace = compilation.AssemblyName!.GetNamespace();
        Generate(spc, "NinoTypeConst.g.cs", () => $$"""
                                                    // <auto-generated/>

                                                    using System;

                                                    namespace {{curNamespace}}
                                                    {
                                                        public static class NinoTypeConst
                                                        {
                                                    {{types}}
                                                        }
                                                    }
                                                    """);

        var (inheritanceMap,
            subTypeMap,
            _) = ninoSymbols.GetInheritanceMap();

        GeneratePartialAccessor(compilation, ninoSymbols, inheritanceMap, subTypeMap, spc);
        Generate(spc, "UnsafeAccessor.g.cs",
            () => GenerateUnsafeAccessor(compilation, ninoSymbols, inheritanceMap, subTypeMap));
        Generate(spc, "Serializer.g.cs",
            () => GenerateSerializer(compilation, ninoSymbols, inheritanceMap, subTypeMap));
        Generate(spc, "Deserializer.g.cs",
            () => GenerateDeserializer(compilation, ninoSymbols, inheritanceMap, subTypeMap));
    }

    private static void Generate(SourceProductionContext spc, string filename, Func<string> codeFunc)
    {
        string code;
        try
        {
            code = codeFunc();
        }
        catch (Exception e)
        {
            code = $"/* Error: {e.Message}";
            //add stacktrace
            foreach (var line in e.StackTrace.Split('\n'))
            {
                code += $" * {line}";
            }

            //end error
            code += " */";
        }

        spc.AddSource(filename, code);
    }

    private static void GeneratePartialAccessor(Compilation compilation,
        List<ITypeSymbol> ninoSymbols,
        Dictionary<string, List<string>> inheritanceMap,
        Dictionary<string, List<string>> subTypeMap,
        SourceProductionContext spc)
    {
        HashSet<string> generatedTypes = new();

        foreach (var typeSymbol in ninoSymbols)
        {
            string typeFullName = typeSymbol.GetTypeFullName();
            bool isPolymorphicType = typeSymbol.IsPolymorphicType();

            // check if struct is unmanaged
            if (typeSymbol.IsUnmanagedType && !isPolymorphicType)
            {
                continue;
            }

            //ensure type is in this compilation, not from referenced assemblies
            if (!typeSymbol.ContainingAssembly.Equals(compilation.Assembly, SymbolEqualityComparer.Default))
            {
                continue;
            }

            void WriteMembers(List<NinoTypeHelper.NinoMember> members, ITypeSymbol type)
            {
                var sb = new StringBuilder();
                bool hasPrivateMembers = false;

                try
                {
                    foreach (var (name, declaredType, _, _, isPrivate, _) in members)
                    {
                        if (!isPrivate)
                        {
                            continue;
                        }

                        var declaringType = declaredType.ToDisplayString();

                        if (type is INamedTypeSymbol nts)
                        {
                            if (nts.TypeParameters.Length > 0)
                            {
                                var member = nts.ConstructedFrom
                                    .GetMembers().FirstOrDefault(m => m.Name == name);
                                if (member != null)
                                {
                                    if (member is IFieldSymbol fieldSymbol)
                                    {
                                        declaringType = fieldSymbol.Type.ToDisplayString();
                                    }
                                    else if (member is IPropertySymbol propertySymbol)
                                    {
                                        declaringType = propertySymbol.Type.ToDisplayString();
                                    }
                                }
                            }
                        }

                        hasPrivateMembers = true;
                        var accessor = $$"""
                                                 internal {{declaringType}} __nino__generated__{{name}}
                                                 {
                                                     [MethodImpl(MethodImplOptions.AggressiveInlining)]
                                                     get => {{name}};
                                                     [MethodImpl(MethodImplOptions.AggressiveInlining)]
                                                     set => {{name}} = value;
                                                 }
                                         """;
                        sb.AppendLine(accessor);
                    }
                }
                catch (Exception e)
                {
                    sb.AppendLine($"/* Error: {e.Message} for type {typeSymbol.GetTypeFullName()}");
                    //add stacktrace
                    foreach (var line in e.StackTrace.Split('\n'))
                    {
                        sb.AppendLine($" * {line}");
                    }

                    //end error
                    sb.AppendLine(" */");
                }

                if (!hasPrivateMembers)
                {
                    return;
                }

                var hasNamespace = !type.ContainingNamespace.IsGlobalNamespace &&
                                   !string.IsNullOrEmpty(type.ContainingNamespace.ToDisplayString());
                var typeNamespace = type.ContainingNamespace.ToDisplayString();
                var modifer = type.GetTypeModifiers();
                //get typename, including type parameters if any
                var typeSimpleName = type.Name;
                //type arguments to type parameters
                if (type is INamedTypeSymbol namedTypeSymbol)
                {
                    var typeParameters = namedTypeSymbol.TypeParameters;
                    if (typeParameters.Length > 0)
                    {
                        typeSimpleName += $"<{string.Join(",", typeParameters.Select(t => t.ToDisplayString()))}>";
                    }
                }

                if (!generatedTypes.Add(typeSimpleName))
                {
                    return;
                }

                var namespaceStr = hasNamespace ? $"namespace {typeNamespace}\n" : "";
                if (hasNamespace)
                {
                    namespaceStr += "{";
                }

                // generate code
                var code = $$"""
                             // <auto-generated/>

                             using System;
                             using System.Runtime.CompilerServices;

                             {{namespaceStr}}
                             #if !NET8_0_OR_GREATER
                                 public partial {{modifer}} {{typeSimpleName}}
                                 {
                             {{sb}}    }
                             #endif
                             """;
                if (hasNamespace)
                {
                    code += "\n}";
                }

                spc.AddSource($"{typeSimpleName.Replace("<", "_").Replace(">", "_").Replace(",", "_")}.g.cs", code);
            }

            if (subTypeMap.TryGetValue(typeFullName, out var lst))
            {
                //sort lst by how deep the inheritance is (i.e. how many levels of inheritance), the deepest first
                lst.Sort((a, b) =>
                {
                    int aCount = inheritanceMap[a].Count;
                    int bCount = inheritanceMap[b].Count;
                    return bCount.CompareTo(aCount);
                });

                foreach (var subType in lst)
                {
                    var subTypeSymbol = ninoSymbols.First(s => s.GetTypeFullName() == subType);
                    if (subTypeSymbol.IsInstanceType())
                    {
                        if (subTypeSymbol.IsUnmanagedType)
                        {
                            continue;
                        }

                        List<ITypeSymbol> subTypeParentSymbols =
                            ninoSymbols.Where(m => inheritanceMap[subType]
                                .Contains(m.GetTypeFullName())).ToList();

                        var members = subTypeSymbol.GetNinoTypeMembers(subTypeParentSymbols);
                        //get distinct members
                        members = members.Distinct().ToList();
                        WriteMembers(members, subTypeSymbol);
                    }
                }
            }

            if (typeSymbol.IsInstanceType())
            {
                if (typeSymbol.IsUnmanagedType)
                {
                    continue;
                }

                List<ITypeSymbol> parentTypeSymbols =
                    ninoSymbols.Where(m => inheritanceMap[typeFullName]
                        .Contains(m.GetTypeFullName())).ToList();
                var defaultMembers = typeSymbol.GetNinoTypeMembers(parentTypeSymbols);
                WriteMembers(defaultMembers, typeSymbol);
            }
        }
    }

    private static string GenerateUnsafeAccessor(Compilation compilation,
        List<ITypeSymbol> ninoSymbols,
        Dictionary<string, List<string>> inheritanceMap,
        Dictionary<string, List<string>> subTypeMap)
    {
        var sb = new StringBuilder();
        var generatedTypes = new HashSet<ITypeSymbol>(SymbolEqualityComparer.Default);

        foreach (var typeSymbol in ninoSymbols)
        {
            try
            {
                string typeFullName = typeSymbol.GetTypeFullName();
                bool isPolymorphicType = typeSymbol.IsPolymorphicType();

                // check if struct is unmanaged
                if (typeSymbol.IsUnmanagedType && !isPolymorphicType)
                {
                    continue;
                }

                void WriteMembers(List<NinoTypeHelper.NinoMember> members, ITypeSymbol type,
                    string typeName)
                {
                    if (!generatedTypes.Add(type))
                    {
                        return;
                    }

                    foreach (var (name, declaredType, _, _, isPrivate, isProperty) in members)
                    {
                        if (!isPrivate)
                        {
                            continue;
                        }

                        if (type.IsValueType)
                        {
                            typeName = $"ref {typeName}";
                        }

                        if (isProperty)
                        {
                            sb.AppendLine(
                                $"        [UnsafeAccessor(UnsafeAccessorKind.Method, Name = \"get_{name}\")]");
                            sb.AppendLine(
                                $"        internal extern static {declaredType.ToDisplayString()} __get__{name}__({typeName} @this);");

                            sb.AppendLine(
                                $"        [UnsafeAccessor(UnsafeAccessorKind.Method, Name = \"set_{name}\")]");
                            sb.AppendLine(
                                $"        internal extern static void __set__{name}__({typeName} @this, {declaredType.ToDisplayString()} value);");
                        }
                        else
                        {
                            sb.AppendLine(
                                $"        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = \"{name}\")]");
                            sb.AppendLine(
                                $"        internal extern static ref {declaredType.ToDisplayString()} __{name}__({typeName} @this);");
                        }
                    }
                }

                if (subTypeMap.TryGetValue(typeFullName, out var lst))
                {
                    //sort lst by how deep the inheritance is (i.e. how many levels of inheritance), the deepest first
                    lst.Sort((a, b) =>
                    {
                        int aCount = inheritanceMap[a].Count;
                        int bCount = inheritanceMap[b].Count;
                        return bCount.CompareTo(aCount);
                    });

                    foreach (var subType in lst)
                    {
                        var subTypeSymbol = ninoSymbols.First(s => s.GetTypeFullName() == subType);
                        if (subTypeSymbol.IsInstanceType())
                        {
                            if (subTypeSymbol.IsUnmanagedType)
                            {
                                continue;
                            }

                            List<ITypeSymbol> subTypeParentSymbols =
                                ninoSymbols.Where(m => inheritanceMap[subType]
                                    .Contains(m.GetTypeFullName())).ToList();

                            var members = subTypeSymbol.GetNinoTypeMembers(subTypeParentSymbols);
                            //get distinct members
                            members = members.Distinct().ToList();
                            WriteMembers(members, subTypeSymbol, subTypeSymbol.ToDisplayString());
                        }
                    }
                }

                if (typeSymbol.IsInstanceType())
                {
                    if (typeSymbol.IsUnmanagedType)
                    {
                        continue;
                    }

                    List<ITypeSymbol> parentTypeSymbols =
                        ninoSymbols.Where(m => inheritanceMap[typeFullName]
                            .Contains(m.GetTypeFullName())).ToList();
                    var defaultMembers = typeSymbol.GetNinoTypeMembers(parentTypeSymbols);
                    WriteMembers(defaultMembers, typeSymbol, typeSymbol.ToDisplayString());
                }
            }
            catch (Exception e)
            {
                sb.AppendLine($"/* Error: {e.Message} for type {typeSymbol.GetTypeFullName()}");
                //add stacktrace
                foreach (var line in e.StackTrace.Split('\n'))
                {
                    sb.AppendLine($" * {line}");
                }

                //end error
                sb.AppendLine(" */");
            }
        }

        var curNamespace = compilation.AssemblyName!.GetNamespace();

        // generate code
        var code = $$"""
                     // <auto-generated/>

                     using System;
                     using System.Runtime.CompilerServices;

                     namespace {{curNamespace}}
                     {
                     #if NET8_0_OR_GREATER
                         internal static partial class PrivateAccessor
                         {
                     {{sb}}    }
                     #endif
                     }
                     """;


        return code;
    }

    private static string GenerateDeserializer(Compilation compilation,
        List<ITypeSymbol> ninoSymbols,
        Dictionary<string, List<string>> inheritanceMap,
        Dictionary<string, List<string>> subTypeMap)
    {
        var sb = new StringBuilder();

        sb.GenerateClassDeserializeMethods("T?", "<T>", "where T : unmanaged");
        sb.GenerateClassDeserializeMethods("T[]", "<T>", "where T : unmanaged");
        sb.GenerateClassDeserializeMethods("T?[]", "<T>", "where T : unmanaged");
        sb.GenerateClassDeserializeMethods("List<T>", "<T>", "where T : unmanaged");
        sb.GenerateClassDeserializeMethods("List<T?>", "<T>", "where T : unmanaged");
        sb.GenerateClassDeserializeMethods("Dictionary<TKey, TValue>", "<TKey, TValue>",
            "where TKey : unmanaged where TValue : unmanaged");
        sb.GenerateClassDeserializeMethods("string");

        foreach (var typeSymbol in ninoSymbols)
        {
            try
            {
                string typeFullName = typeSymbol.GetTypeFullName();
                GenerateDeserializeImplementation(typeSymbol, typeFullName, sb, inheritanceMap,
                    subTypeMap, ninoSymbols);
            }
            catch (Exception e)
            {
                sb.AppendLine($"/* Error: {e.Message} for type {typeSymbol.GetTypeFullName()}");
                //add stacktrace
                foreach (var line in e.StackTrace.Split('\n'))
                {
                    sb.AppendLine($" * {line}");
                }

                //end error
                sb.AppendLine(" */");
            }
        }

        var curNamespace = compilation.AssemblyName!.GetNamespace();

        // generate code
        var code = $$"""
                     // <auto-generated/>

                     using System;
                     using global::Nino.Core;
                     using System.Buffers;
                     using System.Collections.Generic;
                     using System.Collections.Concurrent;
                     using System.Runtime.InteropServices;
                     using System.Runtime.CompilerServices;

                     namespace {{curNamespace}}
                     {
                         public static partial class Deserializer
                         {
                     {{GeneratePrivateDeserializeImplMethodBody("T", "        ", "<T>", "where T : unmanaged")}}
                            
                             [MethodImpl(MethodImplOptions.AggressiveInlining)]
                             public static void Deserialize<T>(ReadOnlySpan<byte> data, out T value) where T : unmanaged
                             {
                                 value = Unsafe.ReadUnaligned<T>(ref MemoryMarshal.GetReference(data));
                             }

                     {{GeneratePrivateDeserializeImplMethodBody("T[]", "        ", "<T>", "where T : unmanaged")}}

                     {{GeneratePrivateDeserializeImplMethodBody("List<T>", "        ", "<T>", "where T : unmanaged")}}

                     {{GeneratePrivateDeserializeImplMethodBody("IList<T>", "        ", "<T>", "where T : unmanaged")}}

                     {{GeneratePrivateDeserializeImplMethodBody("ICollection<T>", "        ", "<T>", "where T : unmanaged")}}

                     {{GeneratePrivateDeserializeImplMethodBody("T?", "        ", "<T>", "where T : unmanaged")}}

                     {{GeneratePrivateDeserializeImplMethodBody("T?[]", "        ", "<T>", "where T : unmanaged")}}
                             
                     {{GeneratePrivateDeserializeImplMethodBody("List<T?>", "        ", "<T>", "where T : unmanaged")}}

                     {{GeneratePrivateDeserializeImplMethodBody("IList<T?>", "        ", "<T>", "where T : unmanaged")}}

                     {{GeneratePrivateDeserializeImplMethodBody("ICollection<T?>", "        ", "<T>", "where T : unmanaged")}}

                     {{GeneratePrivateDeserializeImplMethodBody("Dictionary<TKey, TValue>", "        ", "<TKey, TValue>", "where TKey : unmanaged where TValue : unmanaged")}}

                     {{GeneratePrivateDeserializeImplMethodBody("IDictionary<TKey, TValue>", "        ", "<TKey, TValue>", "where TKey : unmanaged where TValue : unmanaged")}}

                     {{GeneratePrivateDeserializeImplMethodBody("string", "        ")}}
                             
                     {{sb}}    }
                     }
                     """;

        return code;
    }

    private static string GenerateSerializer(Compilation compilation,
        List<ITypeSymbol> ninoSymbols,
        Dictionary<string, List<string>> inheritanceMap,
        Dictionary<string, List<string>> subTypeMap)
    {
        var sb = new StringBuilder();

        sb.GenerateClassSerializeMethods("T?", "<T>", "where T : unmanaged");
        sb.GenerateClassSerializeMethods("T?[]", "<T>", "where T : unmanaged");
        sb.GenerateClassSerializeMethods("List<T>", "<T>", "where T : unmanaged");
        sb.GenerateClassSerializeMethods("List<T?>", "<T>", "where T : unmanaged");
        sb.GenerateClassSerializeMethods("Dictionary<TKey, TValue>", "<TKey, TValue>",
            "where TKey : unmanaged where TValue : unmanaged");
        sb.GenerateClassSerializeMethods("IDictionary<TKey, TValue>", "<TKey, TValue>",
            "where TKey : unmanaged where TValue : unmanaged");
        sb.GenerateClassSerializeMethods("ICollection<T>", "<T>", "where T : unmanaged");
        sb.GenerateClassSerializeMethods("string");

        foreach (var typeSymbol in ninoSymbols)
        {
            try
            {
                string typeFullName = typeSymbol.GetTypeFullName();
                bool isPolymorphicType = typeSymbol.IsPolymorphicType();

                // check if struct is unmanaged
                if (typeSymbol.IsUnmanagedType && !isPolymorphicType)
                {
                    continue;
                }

                sb.GenerateClassSerializeMethods(typeFullName);

                sb.AppendLine($"        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                sb.AppendLine(
                    $"        public static void Serialize(this {typeFullName} value, ref Writer writer)");
                sb.AppendLine("        {");
                if (isPolymorphicType && typeSymbol.IsReferenceType)
                {
                    sb.AppendLine("            switch (value)");
                    sb.AppendLine("            {");
                    sb.AppendLine("                case null:");
                    sb.AppendLine("                    writer.Write(TypeCollector.Null);");
                    sb.AppendLine("                    return;");
                }

                void WriteMembers(List<NinoTypeHelper.NinoMember> members, ITypeSymbol type,
                    string valName)
                {
                    foreach (var (name, declaredType, attrs, _, isPrivate, isProperty) in members)
                    {
                        var val = $"{valName}.{name}";

                        if (isPrivate)
                        {
                            var accessName = valName;
                            if (type.IsValueType)
                            {
                                accessName = $"ref {valName}";
                            }

                            val = isProperty
                                ? $"PrivateAccessor.__get__{name}__({accessName})"
                                : $"PrivateAccessor.__{name}__({accessName})";
                            var legacyVal = $"{valName}.__nino__generated__{name}";
                            val = $"""

                                   #if NET8_0_OR_GREATER
                                                           {val}
                                   #else
                                                           {legacyVal}
                                   #endif 
                                                       
                                   """;
                        }

                        //check if the typesymbol declaredType is string
                        if (declaredType.SpecialType == SpecialType.System_String)
                        {
                            //check if this member is annotated with [NinoUtf8]
                            var isUtf8 = attrs.Any(a => a.AttributeClass!.Name == "NinoUtf8Attribute");

                            sb.AppendLine(
                                isUtf8
                                    ? $"                    writer.WriteUtf8({val});"
                                    : $"                    writer.Write({val});");

                            continue;
                        }

                        sb.AppendLine(
                            $"                    {declaredType.GetSerializePrefix()}({val}, ref writer);");
                    }
                }

                if (subTypeMap.TryGetValue(typeFullName, out var lst))
                {
                    //sort lst by how deep the inheritance is (i.e. how many levels of inheritance), the deepest first
                    lst.Sort((a, b) =>
                    {
                        int aCount = inheritanceMap[a].Count;
                        int bCount = inheritanceMap[b].Count;
                        return bCount.CompareTo(aCount);
                    });

                    foreach (var subType in lst)
                    {
                        var subTypeSymbol = ninoSymbols.First(s => s.GetTypeFullName() == subType);
                        if (subTypeSymbol.IsInstanceType())
                        {
                            string valName = subType.Replace("global::", "").Replace(".", "_").ToLower();
                            sb.AppendLine($"                case {subType} {valName}:");
                            sb.AppendLine(
                                $"                    writer.Write(NinoTypeConst.{subTypeSymbol.GetTypeFullName().GetTypeConstName()});");
                            if (subTypeSymbol.IsUnmanagedType)
                            {
                                sb.AppendLine(
                                    $"                    writer.Write({valName});");
                            }
                            else
                            {
                                List<ITypeSymbol> subTypeParentSymbols =
                                    ninoSymbols.Where(m => inheritanceMap[subType]
                                        .Contains(m.GetTypeFullName())).ToList();

                                var members = subTypeSymbol.GetNinoTypeMembers(subTypeParentSymbols);
                                //get distinct members
                                members = members.Distinct().ToList();
                                WriteMembers(members, subTypeSymbol, valName);
                            }

                            sb.AppendLine("                    return;");
                        }
                    }
                }

                if (typeSymbol.IsInstanceType())
                {
                    if (typeSymbol.IsReferenceType)
                    {
                        sb.AppendLine("                default:");
                    }

                    if (isPolymorphicType)
                    {
                        sb.AppendLine(
                            $"                    writer.Write(NinoTypeConst.{typeSymbol.GetTypeFullName().GetTypeConstName()});");
                    }


                    if (typeSymbol.IsUnmanagedType)
                    {
                        sb.AppendLine("                    writer.Write(value);");
                    }
                    else
                    {
                        List<ITypeSymbol> parentTypeSymbols =
                            ninoSymbols.Where(m => inheritanceMap[typeFullName]
                                .Contains(m.GetTypeFullName())).ToList();
                        var defaultMembers = typeSymbol.GetNinoTypeMembers(parentTypeSymbols);
                        WriteMembers(defaultMembers, typeSymbol, "value");
                    }

                    if (isPolymorphicType && typeSymbol.IsReferenceType)
                    {
                        sb.AppendLine("                    return;");
                    }
                }

                if (isPolymorphicType && typeSymbol.IsReferenceType)
                {
                    sb.AppendLine("            }");
                }

                sb.AppendLine("        }");
                sb.AppendLine();
            }
            catch (Exception e)
            {
                sb.AppendLine($"/* Error: {e.Message} for type {typeSymbol.GetTypeFullName()}");
                //add stacktrace
                foreach (var line in e.StackTrace.Split('\n'))
                {
                    sb.AppendLine($" * {line}");
                }

                //end error
                sb.AppendLine(" */");
            }
        }

        var curNamespace = compilation.AssemblyName!.GetNamespace();

        // generate code
        var code = $$"""
                     // <auto-generated/>

                     using System;
                     using global::Nino.Core;
                     using System.Buffers;
                     using System.Collections.Generic;
                     using System.Collections.Concurrent;
                     using System.Runtime.InteropServices;
                     using System.Runtime.CompilerServices;

                     namespace {{curNamespace}}
                     {
                         public static partial class Serializer
                         {
                             private static readonly ConcurrentQueue<ArrayBufferWriter<byte>> BufferWriters =
                                 new ConcurrentQueue<ArrayBufferWriter<byte>>();
                         
                             [MethodImpl(MethodImplOptions.AggressiveInlining)]
                             public static ArrayBufferWriter<byte> GetBufferWriter()
                             {
                                 if (BufferWriters.Count == 0)
                                 {
                                     return new ArrayBufferWriter<byte>(1024);
                                 }
                         
                                 if (BufferWriters.TryDequeue(out var bufferWriter))
                                 {
                                     return bufferWriter;
                                 }
                         
                                 return new ArrayBufferWriter<byte>(1024);
                             }
                         
                             [MethodImpl(MethodImplOptions.AggressiveInlining)]
                             public static void ReturnBufferWriter(ArrayBufferWriter<byte> bufferWriter)
                             {
                     #if NET8_0_OR_GREATER
                                 bufferWriter.ResetWrittenCount();
                     #else
                                 bufferWriter.Clear();
                     #endif
                                 BufferWriters.Enqueue(bufferWriter);
                             }
                             
                             [MethodImpl(MethodImplOptions.AggressiveInlining)]
                             public static byte[] Serialize<T>(this T value) where T : unmanaged
                             {
                                 byte[] ret = new byte[Unsafe.SizeOf<T>()];
                                 Unsafe.WriteUnaligned(ref ret[0], value);
                                 return ret;
                             }
                             
                             [MethodImpl(MethodImplOptions.AggressiveInlining)]
                             public static void Serialize<T>(this T value, IBufferWriter<byte> bufferWriter) where T : unmanaged
                             {
                                 Writer writer = new Writer(bufferWriter);
                                 value.Serialize(ref writer);
                             }
                             
                             [MethodImpl(MethodImplOptions.AggressiveInlining)]
                             public static byte[] Serialize<T>(this T[] value) where T : unmanaged
                             {
                                 if (value == null)
                                     return new byte[2];
                                 var valueSpan = MemoryMarshal.AsBytes(value.AsSpan());
                                 int size = sizeof(int) + valueSpan.Length;
                                 byte[] ret = new byte[size];
                                 Unsafe.WriteUnaligned(ref ret[0], TypeCollector.GetCollectionHeader(value.Length));
                                 Unsafe.CopyBlockUnaligned(ref ret[4], ref valueSpan[0],
                                     (uint)valueSpan.Length);
                                 return ret;
                             }
                             
                             [MethodImpl(MethodImplOptions.AggressiveInlining)]
                             public static void Serialize<T>(this T[] value, IBufferWriter<byte> bufferWriter) where T : unmanaged
                             {
                                 Writer writer = new Writer(bufferWriter);
                                 value.Serialize(ref writer);
                             }
                             
                             [MethodImpl(MethodImplOptions.AggressiveInlining)]
                             public static byte[] Serialize<T>(this Span<T> value) where T : unmanaged
                             {
                                if (value == Span<T>.Empty)
                                    return new byte[2];
                                var valueSpan = MemoryMarshal.AsBytes(value);
                                int size = sizeof(int) + valueSpan.Length;
                                byte[] ret = new byte[size];
                                Unsafe.WriteUnaligned(ref ret[0], TypeCollector.GetCollectionHeader(value.Length));
                                Unsafe.CopyBlockUnaligned(ref ret[4], ref valueSpan[0],
                                    (uint)valueSpan.Length);
                                return ret;
                             }
                             
                             [MethodImpl(MethodImplOptions.AggressiveInlining)]
                             public static void Serialize<T>(this Span<T> value, IBufferWriter<byte> bufferWriter) where T : unmanaged
                             {
                                 Writer writer = new Writer(bufferWriter);
                                 value.Serialize(ref writer);
                             }
                             
                             [MethodImpl(MethodImplOptions.AggressiveInlining)]
                             public static byte[] Serialize(this bool value)
                             {
                                 if (value)
                                     return new byte[1] { 1 };
                                
                                 return new byte[1] { 0 };
                             }
                             
                             [MethodImpl(MethodImplOptions.AggressiveInlining)]
                             public static byte[] Serialize(this byte value)
                             {
                                 return new byte[1] { value };
                             }

                     {{GeneratePrivateSerializeImplMethodBody("T", "        ", "<T>", "where T : unmanaged")}}

                     {{GeneratePrivateSerializeImplMethodBody("T[]", "        ", "<T>", "where T : unmanaged")}}

                     {{GeneratePrivateSerializeImplMethodBody("T?[]", "        ", "<T>", "where T : unmanaged")}}

                     {{GeneratePrivateSerializeImplMethodBody("List<T>", "        ", "<T>", "where T : unmanaged")}}

                     {{GeneratePrivateSerializeImplMethodBody("Span<T>", "        ", "<T>", "where T : unmanaged")}}
                             
                     {{GeneratePrivateSerializeImplMethodBody("ICollection<T>", "        ", "<T>", "where T : unmanaged")}}
                             
                     {{GeneratePrivateSerializeImplMethodBody("T?", "        ", "<T>", "where T : unmanaged")}}

                     {{GeneratePrivateSerializeImplMethodBody("List<T?>", "        ", "<T>", "where T : unmanaged")}}

                     {{GeneratePrivateSerializeImplMethodBody("ICollection<T?>", "        ", "<T>", "where T : unmanaged")}}
                             
                     {{GeneratePrivateSerializeImplMethodBody("string", "        ")}}

                     {{GeneratePrivateSerializeImplMethodBody("Dictionary<TKey, TValue>", "        ", "<TKey, TValue>", "where TKey : unmanaged where TValue : unmanaged")}}

                     {{sb}}    }
                     }
                     """;

        return code;
    }


    private static string GeneratePrivateSerializeImplMethodBody(string typeName, string indent = "",
        string typeParam = "",
        string genericConstraint = "")
    {
        var ret = $$"""
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    public static void Serialize{{typeParam}}(this {{typeName}} value, ref Writer writer) {{genericConstraint}}
                    {
                        writer.Write(value);
                    }
                    """;

        // indent
        ret = ret.Replace("\n", $"\n{indent}");
        return $"{indent}{ret}";
    }


    private static void GenerateDeserializeImplementation(ITypeSymbol typeSymbol, string typeFullName, StringBuilder sb,
        Dictionary<string, List<string>> inheritanceMap,
        Dictionary<string, List<string>> subTypeMap, List<ITypeSymbol> ninoSymbols)
    {
        bool isPolymorphicType = typeSymbol.IsPolymorphicType();

        // check if struct is unmanaged
        if (typeSymbol.IsUnmanagedType && !isPolymorphicType)
        {
            return;
        }

        sb.GenerateClassDeserializeMethods(typeFullName);

        sb.AppendLine($$"""
                                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                                public static void Deserialize(out {{typeFullName}} value, ref Reader reader)
                                {
                                #if {{NinoTypeHelper.WeakVersionToleranceSymbol}}
                                     if (reader.Eof)
                                     {
                                        value = default;
                                        return;
                                     }
                                #endif
                                     
                        """);

        if (typeSymbol.IsPolymorphicType())
        {
            sb.AppendLine("            reader.Read(out int typeId);");
            sb.AppendLine();
        }

        void WriteMembersWithCustomConstructor(List<NinoTypeHelper.NinoMember> members, ITypeSymbol type,
            string typeName, string valName, string[] constructorMember)
        {
            List<(string, string)> vars = new List<(string, string)>();
            List<(string, string, bool)> privateVars = new List<(string, string, bool)>();
            Dictionary<string, string> args = new Dictionary<string, string>();
            foreach (var (name, declaredType, attrs, isCtorParam, isPrivate, isProperty) in members)
            {
                var t = declaredType.ToDisplayString().Select(c => char.IsLetterOrDigit(c) ? c : '_')
                    .Aggregate("", (a, b) => a + b);
                var tempName = $"{t}_temp_{name}";
                //check if the typesymbol declaredType is string
                if (declaredType.SpecialType == SpecialType.System_String)
                {
                    //check if this member is annotated with [NinoUtf8]
                    var isUtf8 = attrs.Any(a =>
                        a.AttributeClass?.ToDisplayString().EndsWith("NinoUtf8Attribute") == true);

                    sb.AppendLine(
                        isUtf8
                            ? $"                    reader.ReadUtf8(out {declaredType.ToDisplayString()} {tempName});"
                            : $"                    reader.Read(out {declaredType.ToDisplayString()} {tempName});");
                }
                else
                {
                    sb.AppendLine(
                        $"                    {declaredType.GetDeserializePrefix()}(out {declaredType.ToDisplayString()} {tempName}, ref reader);");
                }

                if (constructorMember.Any(c => c.ToLower().Equals(name.ToLower())))
                {
                    args.Add(name, tempName);
                }
                else
                {
                    // we dont want init-only properties from the primary constructor
                    if (!isCtorParam)
                    {
                        if (!isPrivate)
                        {
                            vars.Add((name, tempName));
                        }
                        else
                        {
                            privateVars.Add((name, tempName, isProperty));
                        }
                    }
                }
            }

            sb.AppendLine(
                $"                    {valName} = new {typeName}({string.Join(", ",
                    constructorMember.Select(m =>
                        args[args.Keys
                            .FirstOrDefault(k =>
                                k.ToLower()
                                    .Equals(m.ToLower()))]
                    ))}){(vars.Count > 0 ? "" : ";")}");
            if (vars.Count > 0)
            {
                sb.AppendLine($"                    {new string(' ', valName.Length)}   {{");
                foreach (var (memberName, varName) in vars)
                {
                    sb.AppendLine(
                        $"                 {new string(' ', valName.Length)}      \t{memberName} = {varName},");
                }

                if (privateVars.Count > 0)
                {
                    sb.AppendLine("#if !NET8_0_OR_GREATER");
                    foreach (var (memberName, varName, _) in privateVars)
                    {
                        sb.AppendLine(
                            $"                 {new string(' ', valName.Length)}      \t__nino__generated__{memberName} = {varName},");
                    }

                    sb.AppendLine("#endif");
                }

                sb.AppendLine($"                    {new string(' ', valName.Length)}   }};");
            }

            if (privateVars.Count > 0)
            {
                sb.AppendLine("#if NET8_0_OR_GREATER");
                if (type.IsValueType)
                {
                    valName = $"ref {valName}";
                }

                foreach (var (memberName, varName, isProperty) in privateVars)
                {
                    if (isProperty)
                    {
                        sb.AppendLine(
                            $"                    PrivateAccessor.__set__{memberName}__({valName}, {varName});");
                    }
                    else
                    {
                        sb.AppendLine(
                            $"                    ref var __{varName} = ref PrivateAccessor.__{memberName}__({valName});");
                        sb.AppendLine($"                    __{varName} = {varName};");
                    }
                }

                sb.AppendLine("#endif");
            }
        }

        void CreateInstance(List<NinoTypeHelper.NinoMember> defaultMembers, ITypeSymbol symbol,
            string valName,
            string typeName)
        {
            //if this subtype contains a custom constructor, use it
            //go through all constructors and find the one with the NinoConstructor attribute
            //get constructors of the symbol
            var constructors = (symbol as INamedTypeSymbol)?.Constructors.ToList();

            if (constructors == null)
            {
                sb.AppendLine(
                    $"                    // no constructor found, symbol is not a named type symbol but a {symbol.GetType()}");
                sb.AppendLine(
                    $"                    throw new InvalidOperationException(\"No constructor found for {typeName}\");");
                return;
            }

            IMethodSymbol? constructor = null;

            // if typesymbol is a record, try get the primary constructor
            if (symbol.IsRecord)
            {
                constructor = constructors.FirstOrDefault(c => c.Parameters.Length == 0 || c.Parameters.All(p =>
                    defaultMembers.Any(m => m.Name == p.Name)));
            }

            if (constructor == null)
                constructor = constructors.OrderBy(c => c.Parameters.Length).FirstOrDefault();

            if (constructor == null)
            {
                sb.AppendLine("                    // no constructor found");
                sb.AppendLine(
                    $"                    throw new InvalidOperationException(\"No constructor found for {typeName}\");");
                return;
            }

            var custom = constructors.FirstOrDefault(c => c.GetAttributes().Any(a =>
                a.AttributeClass != null &&
                a.AttributeClass.ToDisplayString().EndsWith("NinoConstructorAttribute")));
            if (custom != null)
            {
                constructor = custom;
            }

            sb.AppendLine($"                    // use {constructor.ToDisplayString()}");

            var attr = constructor.GetNinoConstructorAttribute();
            string[] args;
            if (attr != null)
            {
                //attr is         [NinoConstructor(nameof(a), nameof(b), nameof(c), ...)]
                //we need to get a, b, c, ...
                var args0 = attr.ConstructorArguments[0].Values;
                //should be a string array
                args = args0.Select(a =>
                    a.Value as string).ToArray()!;
            }
            else
            {
                args = constructor.Parameters.Select(p => p.Name).ToArray();
            }

            WriteMembersWithCustomConstructor(defaultMembers, symbol, typeName, valName, args);
        }

        if (!subTypeMap.TryGetValue(typeFullName, out var lst))
        {
            lst = new List<string>();
        }

        //sort lst by how deep the inheritance is (i.e. how many levels of inheritance), the deepest first
        lst.Sort((a, b) =>
        {
            int aCount = inheritanceMap[a].Count;
            int bCount = inheritanceMap[b].Count;
            return bCount.CompareTo(aCount);
        });

        if (isPolymorphicType)
        {
            sb.AppendLine("            switch (typeId)");
            sb.AppendLine("            {");
            if (typeSymbol.IsReferenceType)
            {
                sb.AppendLine("""
                                              case TypeCollector.Null:
                                                  value = null;
                                                  return;
                              """);
            }
        }

        foreach (var subType in lst)
        {
            var subTypeSymbol = ninoSymbols.First(s => s.GetTypeFullName() == subType);

            if (subTypeSymbol.IsInstanceType())
            {
                string valName = subType.Replace("global::", "").Replace(".", "_").ToLower();
                sb.AppendLine(
                    $"                case NinoTypeConst.{subTypeSymbol.GetTypeFullName().GetTypeConstName()}:");
                sb.AppendLine("                {");
                sb.AppendLine($"                    {subType} {valName};");

                if (subTypeSymbol.IsUnmanagedType)
                {
                    sb.AppendLine($"                    reader.Read(out {valName});");
                }
                else
                {
                    //get members
                    List<ITypeSymbol> subTypeParentSymbols =
                        ninoSymbols.Where(m => inheritanceMap[subType]
                            .Contains(m.GetTypeFullName())).ToList();

                    var members = subTypeSymbol.GetNinoTypeMembers(subTypeParentSymbols);
                    //get distinct members
                    members = members.Distinct().ToList();
                    CreateInstance(members, subTypeSymbol, valName, subType);
                }

                sb.AppendLine($"                    value = {valName};");
                sb.AppendLine("                    return;");
                sb.AppendLine("                }");
            }
        }

        if (typeSymbol.IsInstanceType())
        {
            if (isPolymorphicType)
            {
                sb.AppendLine($"                case NinoTypeConst.{typeSymbol.GetTypeFullName().GetTypeConstName()}:");
                sb.AppendLine("                {");
            }

            if (typeSymbol.IsUnmanagedType)
            {
                sb.AppendLine($"                    reader.Read(out value);");
            }
            else
            {
                List<ITypeSymbol> parentTypeSymbols =
                    ninoSymbols.Where(m => inheritanceMap[typeFullName]
                        .Contains(m.GetTypeFullName())).ToList();
                var defaultMembers = typeSymbol.GetNinoTypeMembers(parentTypeSymbols);
                string valName = "value";
                CreateInstance(defaultMembers, typeSymbol, valName, typeFullName);
            }

            if (isPolymorphicType)
            {
                sb.AppendLine("                    return;");
                sb.AppendLine("                }");
            }
        }

        if (isPolymorphicType)
        {
            sb.AppendLine("                default:");
            sb.AppendLine(
                "                    throw new InvalidOperationException($\"Invalid type id {typeId}\");");
            sb.AppendLine("            }");
        }

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static string GeneratePrivateDeserializeImplMethodBody(string typeName, string indent = "",
        string typeParam = "",
        string genericConstraint = "")
    {
        var ret = $$"""
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    public static void Deserialize{{typeParam}}(out {{typeName}} value, ref Reader reader) {{genericConstraint}}
                    {
                    #if {{NinoTypeHelper.WeakVersionToleranceSymbol}}
                         if (reader.Eof)
                         {
                            value = default;
                            return;
                         }
                    #endif
                        
                        reader.Read(out value);
                    }
                    """;

        // indent
        ret = ret.Replace("\n", $"\n{indent}");
        return $"{indent}{ret}";
    }
}